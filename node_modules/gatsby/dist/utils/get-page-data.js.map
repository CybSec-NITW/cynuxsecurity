{"version":3,"sources":["../../src/utils/get-page-data.ts"],"names":["DEFAULT_WAIT_TIMEOUT","RETRY_INTERVAL","getPageData","pagePath","waitForMS","doGetPageData","initialWaitForMs","queries","pendingPageDataWrites","pages","store","getState","has","Error","query","trackedQueries","get","running","waitNextPageData","dirty","emitter","emit","pagePaths","readPageData","remainingTime","Promise","resolve","on","listener","timeout","setTimeout","off","Math","max","min","data","payload","page","clearTimeout","catch","toFixed","program","path","join","directory","err"],"mappings":"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","sourcesContent":["import * as path from \"path\"\nimport { store, emitter } from \"../redux\"\nimport { IClearPendingPageDataWriteAction } from \"../redux/types\"\nimport {\n  IPageDataWithQueryResult,\n  readPageData as readPageDataUtil,\n} from \"./page-data\"\n\nconst DEFAULT_WAIT_TIMEOUT = 15 * 1000\nexport const RETRY_INTERVAL = 5 * 1000\n\nexport async function getPageData(\n  pagePath: string,\n  waitForMS: number = DEFAULT_WAIT_TIMEOUT\n): Promise<IPageDataWithQueryResult> {\n  return doGetPageData(pagePath, waitForMS, waitForMS)\n}\n\nasync function doGetPageData(\n  pagePath: string,\n  waitForMS: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  const { queries, pendingPageDataWrites, pages } = store.getState()\n\n  if (!pages.has(pagePath)) {\n    throw new Error(\n      `Page \"${pagePath}\" doesn't exist. It might have been deleted recently.`\n    )\n  }\n\n  const query = queries.trackedQueries.get(pagePath)\n\n  if (!query) {\n    throw new Error(`Could not find query ${pagePath}`)\n  }\n  if (query.running !== 0) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (query.dirty !== 0) {\n    emitter.emit(`QUERY_RUN_REQUESTED`, { pagePath })\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (pendingPageDataWrites.pagePaths.has(pagePath)) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  // Results are up-to-date\n  return readPageData(pagePath)\n}\n\nasync function waitNextPageData(\n  pagePath: string,\n  remainingTime: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  if (remainingTime > 0) {\n    return new Promise(resolve => {\n      emitter.on(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n\n      const timeout = setTimeout((): void => {\n        emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n        resolve(\n          doGetPageData(\n            pagePath,\n            Math.max(remainingTime - RETRY_INTERVAL, 0),\n            initialWaitForMs\n          )\n        )\n      }, Math.min(RETRY_INTERVAL, remainingTime))\n\n      function listener(data: IClearPendingPageDataWriteAction): void {\n        if (data.payload.page === pagePath) {\n          clearTimeout(timeout)\n          emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n          resolve(readPageData(pagePath))\n        }\n      }\n    })\n  } else {\n    // not ideal ... but try to push results we might have (stale)\n    // or fail/reject\n    return readPageData(pagePath).catch(() => {\n      throw new Error(\n        `Couldn't get query results for \"${pagePath}\" in ${(\n          initialWaitForMs / 1000\n        ).toFixed(3)}s.`\n      )\n    })\n  }\n}\n\nasync function readPageData(pagePath): Promise<IPageDataWithQueryResult> {\n  const { program } = store.getState()\n\n  try {\n    return await readPageDataUtil(\n      path.join(program.directory, `public`),\n      pagePath\n    )\n  } catch (err) {\n    throw new Error(\n      `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n    )\n  }\n}\n"],"file":"get-page-data.js"}