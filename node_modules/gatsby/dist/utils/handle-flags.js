"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _terminalLink = _interopRequireDefault(require("terminal-link"));

var _chalk = _interopRequireDefault(require("chalk"));

var _commonTags = require("common-tags");

var _fastestLevenshtein = require("fastest-levenshtein");

const terminalLink = (text, url) => {
  if (process.env.NODE_ENV === `test`) {
    return `${text} (${url})`;
  } else {
    return (0, _terminalLink.default)(text, url);
  }
};

const handleFlags = (flags, configFlags, executingCommand = process.env.gatsby_executing_command) => {
  // Prepare config flags.
  // Filter out any flags that are set to false.
  const availableFlags = new Map();
  flags.forEach(flag => availableFlags.set(flag.name, flag)); // Find unknown flags someone has in their config to warn them about.

  const unknownConfigFlags = [];

  for (const flagName in configFlags) {
    if (availableFlags.has(flagName)) {
      continue;
    }

    let flagWithMinDistance;
    let minDistance;

    for (const availableFlag of flags) {
      if (availableFlag.name !== flagName) {
        const distanceToFlag = (0, _fastestLevenshtein.distance)(flagName, availableFlag.name);

        if (!flagWithMinDistance || distanceToFlag < minDistance) {
          flagWithMinDistance = availableFlag.name;
          minDistance = distanceToFlag;
        }
      }
    }

    if (flagName) {
      unknownConfigFlags.push({
        flag: flagName,
        didYouMean: flagWithMinDistance && minDistance < 4 ? flagWithMinDistance : ``
      });
    }
  }

  let unknownFlagMessage = ``;

  if (unknownConfigFlags.length > 0) {
    unknownFlagMessage = (0, _commonTags.commaListsAnd)`The following flag(s) found in your gatsby-config.js are not known:`;
    unknownConfigFlags.forEach(flag => unknownFlagMessage += `\n- ${flag === null || flag === void 0 ? void 0 : flag.flag}${(flag === null || flag === void 0 ? void 0 : flag.didYouMean) ? ` (did you mean: ${flag === null || flag === void 0 ? void 0 : flag.didYouMean})` : ``}`);
  }

  let enabledConfigFlags = Object.keys(configFlags).filter(name => configFlags[name] && availableFlags.has(name)).map(flagName => availableFlags.get(flagName)); // If we're in CI, filter out any flags that don't want to be enabled in CI

  if ((0, _gatsbyCoreUtils.isCI)()) {
    enabledConfigFlags = enabledConfigFlags.filter(flag => flag.noCi !== true);
  } // Filter out any flags that aren't for this environment.


  enabledConfigFlags = enabledConfigFlags.filter(flag => flag.command === `all` || flag.command === executingCommand);

  const addIncluded = flag => {
    if (flag.includedFlags) {
      flag.includedFlags.forEach(includedName => {
        const incExp = flags.find(e => e.name == includedName);

        if (incExp) {
          enabledConfigFlags.push(incExp);
          addIncluded(incExp);
        }
      });
    }
  }; // Add to enabledConfigFlags any includedFlags


  enabledConfigFlags.forEach(flag => {
    addIncluded(flag);
  });
  enabledConfigFlags = _lodash.default.uniq(enabledConfigFlags); // TODO remove flags that longer exist.
  //  w/ message of thanks

  const generateFlagLine = flag => {
    let message = ``;
    message += `\n- ${flag.name}`;

    if (flag.experimental) {
      message += ` · ${_chalk.default.white.bgRed.bold(`EXPERIMENTAL`)}`;
    }

    if (flag.umbrellaIssue) {
      message += ` · (${terminalLink(`Umbrella Issue`, flag.umbrellaIssue)})`;
    }

    message += ` · ${flag.description}`;
    return message;
  };

  let message = ``; //  Create message about what flags are active.

  if (enabledConfigFlags.length > 0) {
    message = `The following flags are active:`;
    enabledConfigFlags.forEach(flag => {
      message += generateFlagLine(flag);
    });
    const otherFlagsCount = flags.length - enabledConfigFlags.length;

    if (otherFlagsCount > 0) {
      message += `\n\nThere ${otherFlagsCount === 1 ? `is one other flag` : `are ${otherFlagsCount} other flags`} available that you might be interested in:`;
      const enabledFlagsSet = new Set();
      enabledConfigFlags.forEach(f => enabledFlagsSet.add(f.name));
      flags.forEach(flag => {
        if (!enabledFlagsSet.has(flag.name)) {
          message += generateFlagLine(flag);
        }
      });
    }

    message += `\n`;
  }

  return {
    enabledConfigFlags,
    message,
    unknownFlagMessage
  };
};

var _default = handleFlags;
exports.default = _default;
//# sourceMappingURL=handle-flags.js.map