!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).graphqlWs={})}(this,(function(e){"use strict";const t=Object.prototype.hasOwnProperty;function n(e){return"object"==typeof e&&null!==e}function o(e,n){return t.call(e,n)}function r(e,o){return t.call(e,o)&&n(e[o])}function c(e,n){return t.call(e,n)&&"string"==typeof e[n]}var i;function s(e){if(n(e)){if(!c(e,"type"))return!1;switch(e.type){case i.ConnectionInit:case i.ConnectionAck:return!o(e,"payload")||void 0===e.payload||n(e.payload);case i.Subscribe:return c(e,"id")&&r(e,"payload")&&(!o(e.payload,"operationName")||void 0===e.payload.operationName||null===e.payload.operationName||"string"==typeof e.payload.operationName)&&c(e.payload,"query")&&(!o(e.payload,"variables")||void 0===e.payload.variables||null===e.payload.variables||r(e.payload,"variables"));case i.Next:return c(e,"id")&&r(e,"payload");case i.Error:return c(e,"id")&&(t=e.payload,Array.isArray(t)&&t.length>0&&t.every((e=>"message"in e)));case i.Complete:return c(e,"id");default:return!1}}var t;return!1}function a(e){if(s(e))return e;if("string"!=typeof e)throw new Error("Message not parsable");const t=JSON.parse(e);if(!s(t))throw new Error("Invalid message");return t}function l(e){if(!s(e))throw new Error("Cannot stringify invalid message");return JSON.stringify(e)}!function(e){e.ConnectionInit="connection_init",e.ConnectionAck="connection_ack",e.Subscribe="subscribe",e.Next="next",e.Error="error",e.Complete="complete"}(i||(i={})),e.createClient=function(e){const{url:t,connectionParams:o,lazy:r=!0,keepAlive:c=0,retryAttempts:s=5,retryTimeout:u=3e3,on:d,webSocketImpl:f,generateID:p=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(e=>{const t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)}))}}=e;let y;if(f){if(!("function"==typeof(m=f)&&"constructor"in m&&"CLOSED"in m&&"CLOSING"in m&&"CONNECTING"in m&&"OPEN"in m))throw new Error("Invalid WebSocket implementation provided");y=f}else"undefined"!=typeof WebSocket?y=WebSocket:"undefined"!=typeof global?y=global.WebSocket||global.MozWebSocket:"undefined"!=typeof window&&(y=window.WebSocket||window.MozWebSocket);var m;if(!y)throw new Error("WebSocket implementation missing");const w=y,b=(()=>{const e={connecting:(null==d?void 0:d.connecting)?[d.connecting]:[],connected:(null==d?void 0:d.connected)?[d.connected]:[],closed:(null==d?void 0:d.closed)?[d.closed]:[]};return{on(t,n){const o=e[t];return o.push(n),()=>{o.splice(o.indexOf(n),1)}},emit(t,...n){for(const o of e[t])o(...n)},reset(){Object.keys(e).forEach((t=>{e[t]=[]}))}}})();let g,k,x={socket:null,acknowledged:!1,locks:0,tries:0};async function v(e,n=0){if(n>10)throw new Error("Kept trying to connect but the socket never settled.");if(x.socket)switch(x.socket.readyState){case w.OPEN:return x.acknowledged?h(x.socket,e):(await new Promise((e=>setTimeout(e,300))),v(e,n+1));case w.CONNECTING:return await new Promise((e=>setTimeout(e,300))),v(e,n+1);case w.CLOSED:break;case w.CLOSING:return await new Promise((e=>setTimeout(e,300))),v(e,n+1);default:throw new Error(`Impossible ready state ${x.socket.readyState}`)}const r=new w(t,"graphql-transport-ws");return x=Object.assign(Object.assign({},x),{acknowledged:!1,socket:r,tries:x.tries+1}),b.emit("connecting"),await new Promise(((t,n)=>{let c=!1;e.current=()=>c=!0;const s=setTimeout((()=>{r.close(3408,"Waited 5 seconds but socket connect never settled")}),5e3);r.onclose=e=>(r.onclose=null,clearTimeout(s),x=Object.assign(Object.assign({},x),{acknowledged:!1,socket:null}),b.emit("closed",e),n(e)),r.onmessage=e=>{if(r.onmessage=null,c)r.close(3499,"Client cancelled the socket before connecting");else try{const n=a(e.data);if(n.type!==i.ConnectionAck)throw new Error(`First message cannot be of type ${n.type}`);return clearTimeout(s),x=Object.assign(Object.assign({},x),{acknowledged:!0,socket:r,tries:0}),b.emit("connected",r,n.payload),t()}catch(e){r.close(4400,e instanceof Error?e.message:new Error(e).message)}},r.onopen=()=>{r.onopen=null,c?r.close(3499,"Client cancelled the socket before connecting"):(async()=>{try{r.send(l({type:i.ConnectionInit,payload:"function"==typeof o?await o():o}))}catch(e){r.close(4400,e instanceof Error?e.message:new Error(e).message)}})()}})),h(r,e)}async function h(e,t){return[e,n=>new Promise(((o,r)=>{if(e.readyState===w.CLOSED)return r(new Error("Socket has already been closed"));function i(n){return t.current=null,x.locks--,e.removeEventListener("close",i),r(n)}x.locks++,e.addEventListener("close",i),t.current=()=>(t.current=null,null==n||n(),x.locks--,x.locks||(c>0&&isFinite(c)?setTimeout((()=>{!x.locks&&e.OPEN&&e.close(1e3,"Normal Closure")}),c):e.close(1e3,"Normal Closure")),e.removeEventListener("close",i),o())}))]}function E(e){if(!function(e){return n(e)&&"code"in e&&"reason"in e}(e))throw e;if([1002,1011,4400,4401,4409,4429].includes(e.code))throw e;if(1e3===e.code)return!1;if(3499===e.code)return!1;if(!s||x.tries>s)throw e;return!0}return r||(async()=>{for(;;)try{const[,e]=await v({current:null});return void await e()}catch(e){if(!E(e))return;await new Promise((e=>setTimeout(e,u)))}})(),{on:b.on,subscribe(e,t){const n=p();let o=!1;const r={current:null},c=({data:e})=>{const c=function(e){return e!==g&&(k=a(e),g=e),k}(e);switch(c.type){case i.Next:return void(c.id===n&&t.next(c.payload));case i.Error:return void(c.id===n&&(t.error(c.payload),r.current()));case i.Complete:return void(c.id===n&&(o=!0,r.current()))}};return(async()=>{for(;;)try{const[t,s]=await v(r);return t.addEventListener("message",c),t.send(l({id:n,type:i.Subscribe,payload:e})),await s((()=>{o||t.send(l({id:n,type:i.Complete}))})),void t.removeEventListener("message",c)}catch(e){if(!E(e))return;await new Promise((e=>setTimeout(e,u)))}})().catch(t.error).then(t.complete),()=>{var e;null===(e=r.current)||void 0===e||e.call(r)}},dispose(){var e;null===(e=x.socket)||void 0===e||e.close(1e3,"Normal Closure"),b.reset()}}},Object.defineProperty(e,"__esModule",{value:!0})}));
